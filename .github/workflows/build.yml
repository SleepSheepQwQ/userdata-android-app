name: Build Android APK

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 获取完整历史
        
    - name: Deep repository analysis
      run: |
        echo "=== 深度仓库结构分析 ==="
        echo "当前工作目录: $(pwd)"
        echo "Git仓库根目录: $(git rev-parse --show-toplevel)"
        echo ""
        
        echo "=== 完整目录树 ==="
        find . -type f -name "*.toml" -o -name "*.rs" -o -name "*.xml" -o -name "*.gradle" | head -50
        echo ""
        
        echo "=== 所有Cargo.toml位置 ==="
        find . -name "Cargo.toml" -exec echo "文件: {}" \; -exec dirname {} \; -exec head -10 {} \;
        echo ""
        
        echo "=== 目录结构深度分析 ==="
        find . -type d | sort | head -30
        echo ""
        
        echo "=== 检查是否有Android项目结构 ==="
        find . -name "AndroidManifest.xml" -o -name "build.gradle" -o -name "gradlew" | head -10
        echo ""
        
        echo "=== 检查是否有userdata_rust目录 ==="
        if [ -d "userdata_rust" ]; then
          echo "userdata_rust目录存在，内容："
          ls -la userdata_rust/
          echo ""
          if [ -f "userdata_rust/Cargo.toml" ]; then
            echo "userdata_rust/Cargo.toml内容："
            cat userdata_rust/Cargo.toml
          fi
        else
          echo "userdata_rust目录不存在"
        fi
        
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Setup Android SDK with multiple fallbacks
      run: |
        echo "=== Android SDK设置 - 方案1: 官方最新版 ==="
        wget -q https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip
        unzip -q commandlinetools-linux-11076708_latest.zip
        mkdir -p $HOME/android-sdk/cmdline-tools/latest
        mv cmdline-tools/* $HOME/android-sdk/cmdline-tools/latest/
        
        echo "ANDROID_HOME=$HOME/android-sdk" >> $GITHUB_ENV
        echo "ANDROID_SDK_ROOT=$HOME/android-sdk" >> $GITHUB_ENV
        echo "$HOME/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
        echo "$HOME/android-sdk/platform-tools" >> $GITHUB_PATH
        
    - name: Install Android components with fallbacks
      run: |
        echo "=== 安装Android组件 ==="
        
        # 方案1: 尝试安装指定版本
        echo "尝试安装指定版本组件..."
        yes | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager --licenses || echo "License accept failed"
        
        $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "platform-tools" || echo "platform-tools install failed"
        $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "platforms;android-34" || echo "android-34 install failed"
        $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "build-tools;34.0.0" || echo "build-tools 34.0.0 failed"
        
        # 方案2: 如果34.0.0失败，尝试30.0.3
        if ! $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "build-tools;34.0.0" 2>/dev/null; then
          echo "尝试安装build-tools 30.0.3..."
          $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "build-tools;30.0.3" || echo "build-tools 30.0.3 failed"
        fi
        
        # 方案3: NDK安装，多个版本备选
        NDK_VERSIONS=("25.1.8937393" "25.2.9519653" "26.1.10909125")
        for version in "${NDK_VERSIONS[@]}"; do
          echo "尝试安装NDK版本: $version"
          if $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager "ndk;$version" 2>/dev/null; then
            echo "NDK $version 安装成功"
            echo "NDK_HOME=$ANDROID_HOME/ndk/$version" >> $GITHUB_ENV
            echo "ANDROID_NDK_HOME=$ANDROID_HOME/ndk/$version" >> $GITHUB_ENV
            break
          else
            echo "NDK $version 安装失败，尝试下一个版本"
          fi
        done
        
    - name: Setup NDK environment with multiple strategies
      run: |
        echo "=== NDK环境配置 - 多种策略 ==="
        
        if [ -n "$NDK_HOME" ] && [ -d "$NDK_HOME" ]; then
          echo "策略1: 使用安装的NDK"
          NDK_PATH="$NDK_HOME"
        else
          echo "策略2: 尝试查找现有NDK"
          NDK_PATH=$(find $ANDROID_HOME -name "ndk" -type d | head -1)
          if [ -n "$NDK_PATH" ]; then
            NDK_PATH=$(find $NDK_PATH -maxdepth 1 -type d -name "2*" | head -1)
          fi
        fi
        
        if [ -z "$NDK_PATH" ] || [ ! -d "$NDK_PATH" ]; then
          echo "策略3: 手动下载NDK"
          wget -q https://dl.google.com/android/repository/android-ndk-r25b-linux.zip
          unzip -q android-ndk-r25b-linux.zip
          NDK_PATH="$PWD/android-ndk-r25b"
        fi
        
        echo "最终NDK路径: $NDK_PATH"
        echo "NDK_PATH=$NDK_PATH" >> $GITHUB_ENV
        echo "ANDROID_NDK_HOME=$NDK_PATH" >> $GITHUB_ENV
        
        # 设置编译器路径 - 多种备选
        TOOLCHAIN_PATH="$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin"
        if [ -d "$TOOLCHAIN_PATH" ]; then
          echo "$TOOLCHAIN_PATH" >> $GITHUB_PATH
          
          # 检查编译器存在性
          CLANG_COMPILERS=("$TOOLCHAIN_PATH/aarch64-linux-android21-clang" "$TOOLCHAIN_PATH/aarch64-linux-android-clang" "$TOOLCHAIN_PATH/clang")
          
          for compiler in "${CLANG_COMPILERS[@]}"; do
            if [ -f "$compiler" ]; then
              echo "找到编译器: $compiler"
              echo "CC_aarch64_linux_android=$compiler" >> $GITHUB_ENV
              echo "CXX_aarch64_linux_android=${compiler}++" >> $GITHUB_ENV
              echo "AR_aarch64_linux_android=$TOOLCHAIN_PATH/llvm-ar" >> $GITHUB_ENV
              break
            fi
          done
        fi
        
    - name: Install Rust with multiple toolchains
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android,armv7-linux-androideabi,i686-linux-android,x86_64-linux-android
        
    - name: Install cargo-apk and alternatives
      run: |
        echo "=== 安装构建工具 ==="
        
        # 主方案: cargo-apk
        if cargo install cargo-apk; then
          echo "cargo-apk安装成功"
        else
          echo "cargo-apk安装失败，尝试从源码安装..."
          cargo install --git https://github.com/rust-mobile/cargo-apk || echo "cargo-apk完全安装失败"
        fi
        
    - name: Multiple project detection strategies
      run: |
        echo "=== 多种项目检测策略 ==="
        
        # 策略1: 查找所有Cargo.toml
        CARGO_PROJECTS=$(find . -name "Cargo.toml" -exec dirname {} \;)
        echo "找到的项目: $CARGO_PROJECTS"
        
        # 策略2: 智能选择主项目
        MAIN_PROJECT=""
        MAX_RS_FILES=0
        
        for project in $CARGO_PROJECTS; do
          RS_COUNT=$(find "$project" -name "*.rs" -type f 2>/dev/null | wc -l)
          echo "项目 $project 有 $RS_COUNT 个Rust文件"
          
          if [ $RS_COUNT -gt $MAX_RS_FILES ]; then
            MAX_RS_FILES=$RS_COUNT
            MAIN_PROJECT="$project"
          fi
        done
        
        if [ -n "$MAIN_PROJECT" ]; then
          echo "选择主项目: $MAIN_PROJECT"
          echo "MAIN_PROJECT=$MAIN_PROJECT" >> $GITHUB_ENV
        else
          echo "策略3: 使用userdata_rust作为备选"
          if [ -d "userdata_rust" ] && [ -f "userdata_rust/Cargo.toml" ]; then
            echo "MAIN_PROJECT=userdata_rust" >> $GITHUB_ENV
          else
            echo "策略4: 使用根目录"
            echo "MAIN_PROJECT=." >> $GITHUB_ENV
          fi
        fi
        
    - name: Validate project structure
      run: |
        echo "=== 验证项目结构 ==="
        echo "选择的项目: ${{ env.MAIN_PROJECT }}"
        
        cd ${{ env.MAIN_PROJECT }}
        echo "当前目录: $(pwd)"
        echo "目录内容:"
        ls -la
        
        if [ -f "Cargo.toml" ]; then
          echo "Cargo.toml存在，内容:"
          cat Cargo.toml
        else
          echo "ERROR: Cargo.toml不存在"
          exit 1
        fi
        
    - name: Multiple build strategies
      run: |
        cd ${{ env.MAIN_PROJECT }}
        echo "=== 多种构建策略 ==="
        
        # 策略1: 清理环境
        cargo clean
        
        # 策略2: 检查依赖
        echo "检查依赖..."
        if cargo check --target aarch64-linux-android; then
          echo "依赖检查成功"
        else
          echo "依赖检查失败，尝试更新..."
          cargo update
        fi
        
        # 策略3: 尝试cargo-apk构建
        echo "尝试cargo-apk构建..."
        if command -v cargo-apk &> /dev/null; then
          cargo apk build --release --target aarch64-linux-android --verbose || echo "cargo-apk构建失败"
        else
          echo "cargo-apk不可用"
        fi
        
        # 策略4: 尝试标准cargo构建
        echo "尝试标准cargo构建..."
        if cargo build --release --target aarch64-linux-android --verbose; then
          echo "标准构建成功"
        else
          echo "标准构建失败"
        fi
        
        # 策略5: 尝试不同目标
        echo "尝试不同构建目标..."
        for target in aarch64-linux-android armv7-linux-androideabi; do
          echo "尝试目标: $target"
          cargo build --release --target $target --verbose || echo "目标 $target 构建失败"
        done
        
    - name: Comprehensive artifact analysis
      run: |
        echo "=== 全面构建产物分析 ==="
        
        # 从根目录搜索所有产物
        echo "搜索所有.so文件:"
        find . -name "*.so" -exec ls -la {} \; 2>/dev/null || echo "未找到.so文件"
        
        echo "搜索所有APK文件:"
        find . -name "*.apk" -exec ls -la {} \; 2>/dev/null || echo "未找到APK文件"
        
        echo "搜索所有.a文件:"
        find . -name "*.a" -exec ls -la {} \; 2>/dev/null || echo "未找到.a文件"
        
        # 分析target目录
        echo "分析target目录结构:"
        find . -type d -name "target" -exec find {} -type f \; 2>/dev/null | head -20 || echo "无target目录"
        
    - name: Create APK manually if needed
      run: |
        echo "=== 手动创建APK（如果需要）=== "
        
        # 查找.so文件
        SO_FILE=$(find . -name "*.so" -type f | head -1)
        
        if [ -n "$SO_FILE" ]; then
          echo "找到.so文件: $SO_FILE"
          
          # 创建简单的APK结构
          mkdir -p manual_apk/lib/arm64-v8a
          cp "$SO_FILE" manual_apk/lib/arm64-v8a/
          
          # 创建AndroidManifest.xml
          cat > manual_apk/AndroidManifest.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.userdata_rust"
    android:versionCode="1"
    android:versionName="1.0">
    
    <application android:label="userdata_rust">
    </application>
</manifest>
EOF
          
          # 打包APK
          cd manual_apk
          zip -r ../manual_apk.apk .
          cd ..
          
          echo "手动创建APK: manual_apk.apk"
          ls -la manual_apk.apk
        else
          echo "未找到.so文件，无法手动创建APK"
        fi
        
    - name: Upload all artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: comprehensive-build-results
        path: |
          ${{ env.MAIN_PROJECT }}/target/
          manual_apk.apk
          ${{ env.MAIN_PROJECT }}/Cargo.toml
        retention-days: 7
